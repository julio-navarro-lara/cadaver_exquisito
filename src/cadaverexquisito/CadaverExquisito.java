/*
 * CadaverExquisito.java
 *
 * Created on 02-abr-2010, 20:37:46
 *
 * By Julio Navarro Lara
 * *********************
 * Telemática Aplicada - 3º Ing. de Telecomunicaciones
 */

package cadaverexquisito;

import java.awt.*;
import java.net.UnknownHostException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.StringTokenizer;
import java.util.Random;
import javax.swing.event.*;
import java.net.Socket;
import java.io.*;
import javax.swing.*;

/**
 * Este programa es una suerte de imitación del Paint de Windows, preparado para que varios
 * usuarios cooperen en el dibujo y crear así un "cadáver exquisito" surrealista.
 * @author Julio Navarro Lara
 */
public class CadaverExquisito extends javax.swing.JFrame implements ChangeListener{

    /*
     * Color que estará activo en cada trazo
     */
    private Color colorActivo;

    /*
     * Definición de los sockets y flujos necesarios para el intercambio de datos
     */
    private Socket socket;
    private Socket socket2;
    private PrintWriter out;
    private BufferedReader in;

    /*
     * Generador de números aleatorios para las funcionalidades de "Color aleatorio"
     * y trazo "Multicolor"
     */
    private Random alea;

    /*
     * Número que se le asigna a este usuario dentro del servidor
     */
    private int numero;

    /*
     * Grosor del trazo
     */
    private int grosor;

    /*
     * Posición actual del trazo
     */
    private int xactual;
    private int yactual;

    private boolean conectado; //Indica si el usuario está o no conectado
    private int puerto; //Indica el puerto al que se conecta

    /**
     * Constructor de la clase
     */
    public CadaverExquisito() {
        colorActivo = Color.BLACK; //Se pone como negro el color inicial del trazo

        alea = new Random(); //Inicializamos el generador de números aleatorios

        initComponents(); //Iniciamos los componentes de la ventana

        etiquetaFino.doClick(); //Activamos el primer nivel de grosor

        canvas.setIgnoreRepaint(true); //Ignoramos los repaint para que no se borre
                                       //el dibujo tras cada trazo

        //Le añadimos el listener a la paleta de colores
        jColorChooser1.getSelectionModel().addChangeListener(this);

        //Indicamos que no está conectado en un principio
        conectado = false;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        botonesTrazo = new javax.swing.ButtonGroup();
        etiquetaIP = new javax.swing.JLabel();
        etiquetaPuerto = new javax.swing.JLabel();
        textoIP = new javax.swing.JTextField();
        textoPuerto = new javax.swing.JTextField();
        botonConexion = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        etiquetaFino = new javax.swing.JRadioButton();
        etiquetaMedio = new javax.swing.JRadioButton();
        etiquetaGrueso = new javax.swing.JRadioButton();
        JPanel1 = new javax.swing.JPanel();
        canvas = new java.awt.Canvas();
        jColorChooser1 = new javax.swing.JColorChooser();
        info = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        checkAleatorio = new javax.swing.JCheckBox();
        checkMulticolor = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Cadáver Exquisito");
        setBackground(new java.awt.Color(0, 0, 0));
        setFocusCycleRoot(false);

        etiquetaIP.setText("Dirección IP:");

        etiquetaPuerto.setText("Puerto:");

        textoIP.setText("127.0.0.1");

        textoPuerto.setText("24");

        botonConexion.setText("Conectarse");
        botonConexion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonConexionActionPerformed(evt);
            }
        });

        jLabel1.setText("Trazo:");

        botonesTrazo.add(etiquetaFino);
        etiquetaFino.setText("Fino");
        etiquetaFino.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                etiquetaFinoActionPerformed(evt);
            }
        });

        botonesTrazo.add(etiquetaMedio);
        etiquetaMedio.setText("Medio");
        etiquetaMedio.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                etiquetaMedioActionPerformed(evt);
            }
        });

        botonesTrazo.add(etiquetaGrueso);
        etiquetaGrueso.setText("Grueso");
        etiquetaGrueso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                etiquetaGruesoActionPerformed(evt);
            }
        });

        JPanel1.setBackground(new java.awt.Color(255, 255, 255));
        JPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        JPanel1.setFocusCycleRoot(true);

        canvas.setCursor(new java.awt.Cursor(java.awt.Cursor.CROSSHAIR_CURSOR));
        canvas.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                canvasMousePressed(evt);
            }
        });
        canvas.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                canvasMouseDragged(evt);
            }
        });

        javax.swing.GroupLayout JPanel1Layout = new javax.swing.GroupLayout(JPanel1);
        JPanel1.setLayout(JPanel1Layout);
        JPanel1Layout.setHorizontalGroup(
            JPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(canvas, javax.swing.GroupLayout.PREFERRED_SIZE, 741, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        JPanel1Layout.setVerticalGroup(
            JPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(canvas, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 513, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        info.setText("Estado: no conectado");

        jButton1.setText("Apunte histórico");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                apunteHistorico(evt);
            }
        });

        checkAleatorio.setText("Color aleatorio");

        checkMulticolor.setText("Multicolor");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(JPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jColorChooser1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(etiquetaPuerto, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(etiquetaIP, javax.swing.GroupLayout.Alignment.LEADING))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(textoPuerto)
                                    .addComponent(textoIP, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(botonConexion)))
                        .addContainerGap(48, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(info, javax.swing.GroupLayout.PREFERRED_SIZE, 210, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 107, Short.MAX_VALUE)
                        .addComponent(jButton1)
                        .addGap(49, 49, 49))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(etiquetaFino)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(etiquetaMedio)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(etiquetaGrueso)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 102, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkMulticolor)
                            .addComponent(checkAleatorio))
                        .addGap(86, 86, 86))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jColorChooser1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(etiquetaFino)
                            .addComponent(etiquetaMedio)
                            .addComponent(etiquetaGrueso)
                            .addComponent(checkAleatorio))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkMulticolor)
                        .addGap(11, 11, 11)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(etiquetaIP)
                            .addComponent(textoIP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(etiquetaPuerto)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(textoPuerto, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(botonConexion)))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(info)
                            .addComponent(jButton1)))
                    .addComponent(JPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Gestión del evento de pulsado del botón de conexión.
     * @param evt
     */
    private void botonConexionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonConexionActionPerformed
        try {
            //Deshabilitamos el botón de conexión
            botonConexion.setEnabled(false);

            info.setText("Conectando..."); //Mostramos la información

            //Recogemos el puerto e iniciamos el socket correspondiente (de salida)
            puerto = Integer.parseInt(textoPuerto.getText());
            socket = new Socket(textoIP.getText(), puerto);

            //Creamos los flujos
            out = new PrintWriter(socket.getOutputStream(),true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            //Leemos el número que nos asigna el servidor
            numero = Integer.parseInt(in.readLine());

            //Creamos el segundo socket (de entrada)
            socket2 = new Socket(textoIP.getText(), puerto);

            //Iniciamos una nueva hebra de entrada, que recogerá los trazos de los demás
            //usuarios enviados por el servidor.
            new HebraEntrada(this, socket2).start();

            //Indicamos que estamos conectados, tanto en la variable como con el texto
            conectado = true;
            info.setText("Estado: conectado");
        } catch (UnknownHostException ex) {
            info.setText("No se encuentra el servidor");
        } catch (IOException ex) {
            info.setText("Fallo al conectar");
        }
    }//GEN-LAST:event_botonConexionActionPerformed

    /**
     * Controla el marcador de trazo fino
     * @param evt
     */
    private void etiquetaFinoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_etiquetaFinoActionPerformed
        grosor = 0;
    }//GEN-LAST:event_etiquetaFinoActionPerformed

    /**
     * Controla el marcador de trazo grueso
     * @param evt
     */
    private void etiquetaGruesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_etiquetaGruesoActionPerformed
        grosor = 2;
    }//GEN-LAST:event_etiquetaGruesoActionPerformed

    /**
     * Controla el marcador de trazo medio
     * @param evt
     */
    private void etiquetaMedioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_etiquetaMedioActionPerformed
        grosor = 1;
    }//GEN-LAST:event_etiquetaMedioActionPerformed

    /**
     * Este método detecta cuándo el ratón es arrastrado y dibuja el trazo correspondiente
     * @param evt
     */
    private void canvasMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMouseDragged

        //Si la casilla de multicolor está seleccionada, cambiamos a un color aleatorio en cada
        //trazo para obtener un trazo completo multicolor
        if(checkMulticolor.isSelected()){
            colorActivo = new Color((int)(alea.nextFloat()*255),
                    (int)(alea.nextFloat()*255),(int)(alea.nextFloat()*255));
        }

        //Establecemos el color al que está activo ahora mismo
        canvas.setForeground(colorActivo);
        //Dibujamos la línea entre las coordenadas guardadas antes del arrastre y las actuales
        canvas.getGraphics().drawLine(xactual, yactual, evt.getX(), evt.getY());

        //Según el grosor seleccionado, vamos superponiendo líneas a los lados para obtener un trazo
        //más o menos grueso
        if(grosor > 0){
            canvas.getGraphics().drawLine(xactual+1, yactual, evt.getX()+1, evt.getY());
            canvas.getGraphics().drawLine(xactual, yactual+1, evt.getX(), evt.getY()+1);
            canvas.getGraphics().drawLine(xactual+2, yactual, evt.getX()+2, evt.getY());
            canvas.getGraphics().drawLine(xactual, yactual+2, evt.getX(), evt.getY()+2);
            if(grosor == 2){
                canvas.getGraphics().drawLine(xactual+3, yactual, evt.getX()+3, evt.getY());
                canvas.getGraphics().drawLine(xactual, yactual+3, evt.getX(), evt.getY()+3);
                canvas.getGraphics().drawLine(xactual+4, yactual, evt.getX()+4, evt.getY());
                canvas.getGraphics().drawLine(xactual, yactual+4, evt.getX(), evt.getY()+4);
            }
        }

        //Si estamos conectados, habrá que mandar a los otros la información
        if(conectado){
            try{
                //Enviamos la información del trazo recién realizado (coordenadas, color y grosor)
                out.println(numero+","+xactual+","+evt.getX()+","+yactual+","+evt.getY()+","+
                        colorActivo.getRed()+","+colorActivo.getGreen()+","+colorActivo.getBlue()+","+grosor);

                //Esperamos la confirmación del servidor
                if(!in.readLine().equals("ok")){
                    System.out.println("Fallo en la escritura de datos");
                }

            }catch(IOException e){
                System.out.println("Fallo en lectura");
            }
        }

        //Actualizamos las coordenadas actuales
        xactual = evt.getX();
        yactual = evt.getY();
    }//GEN-LAST:event_canvasMouseDragged

    /**
     * Detecta cuando se pulsa el ratón
     * @param evt
     */
    private void canvasMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMousePressed
        //Si se pulsa el ratón, debemos recoger las coordenadas con miras a que luego pueda
        //realizarse un arrastre (dibujarse un trazo)
        xactual = evt.getX();
        yactual = evt.getY();

        //Si el marcador de color aleatorio está seleccionado, asignamos un nuevo color
        //aleatorio para el siguiente trazo
        if(checkAleatorio.isSelected()){
            colorActivo = new Color((int)(alea.nextFloat()*255),
                    (int)(alea.nextFloat()*255),(int)(alea.nextFloat()*255));
        }
    }//GEN-LAST:event_canvasMousePressed

    /**
     * Abre una ventana nueva con un breve apunte histórico
     * @param evt
     */
    private void apunteHistorico(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_apunteHistorico
        JDialog ventana = new JDialog(this, true);
        ventana.setTitle("Apunte Histórico");
        ventana.setLocation(500, 150);
        ventana.setSize(524, 340);
        ventana.setResizable(false);
        JTextArea texto = new JTextArea();
        texto.setEditable(false);
        texto.append(
                " \n     Un cadáver exquisito no es más que una obra artística creada por varias personas a" +
                " \n  la vez. Cada cual escribe o dibuja un trozo de la obra, formándose así un texto o dibujo" +
                " \n  extraño, una combinación de los pensamientos de todos. Este concepto fue muy usado por " +
                " \n  los surrealistas y dadaístas de los años 20 del siglo pasado, y era una forma de creación" +
                " \n  inconsciente en la que colaboraron los más grandes artistas de la época.\n" +
                " \n     Este programa pretende facilitar la creación de estos cadáveres exquisitos en el ámbito" +
                " \n  del dibujo, permitiendo a varios usuarios dibujar a la vez sobre el mismo lienzo y con " +
                " \n  diferentes colores y grosores. Un programa que seguramente fascinaría a los surrealistas " +
                " \n  por permitir la elaboración del dibujo de forma simultánea, sin que unas manos interfieran" +
                " \n  con otras. \n" +
                " \n     Como nota personal, yo y mis compañeros comenzamos haciendo lo que denominábamos " +
                " \n  \"dibujo colectivo\" durante las aburridas explicaciones de 6º de primaria, y de ahí viene" +
                " \n  mi curiosidad por este tipo de expresión artística y la razón por la que he hecho este " +
                " \n  programa.\n" +
                " \n                                         Julio Navarro Lara");
        ventana.add(texto);
        ventana.setVisible(true);
    }//GEN-LAST:event_apunteHistorico

    /**
     * Método que registra cuando se elige un nuevo color del panel
     * @param e
     */
    public void stateChanged(ChangeEvent e) {
        //Tomamos el color seleccionado como color activo
        colorActivo = jColorChooser1.getColor();
    }

    /**
     * Método que devuelve el lienzo dónde se pinta
     * @return
     */
    public java.awt.Canvas getCanvas(){
        return canvas;
    }

    /**
     * Método main para ejecutar el programa
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CadaverExquisito().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel JPanel1;
    private javax.swing.JButton botonConexion;
    private javax.swing.ButtonGroup botonesTrazo;
    private java.awt.Canvas canvas;
    private javax.swing.JCheckBox checkAleatorio;
    private javax.swing.JCheckBox checkMulticolor;
    private javax.swing.JRadioButton etiquetaFino;
    private javax.swing.JRadioButton etiquetaGrueso;
    private javax.swing.JLabel etiquetaIP;
    private javax.swing.JRadioButton etiquetaMedio;
    private javax.swing.JLabel etiquetaPuerto;
    private javax.swing.JLabel info;
    private javax.swing.JButton jButton1;
    private javax.swing.JColorChooser jColorChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JTextField textoIP;
    private javax.swing.JTextField textoPuerto;
    // End of variables declaration//GEN-END:variables

}

/**
 * Esta clase corresponde a una hebra adicional para recibir los trazos de los otros usuarios
 * @author Julio Navarro Lara
 */
class HebraEntrada extends Thread{

    //Flujos de salida y entrada
    PrintWriter out2;
    BufferedReader in2;

    //Variable booleana para cesar la ejecución
    boolean salir;

    //Clase principal a la que está ligada
    CadaverExquisito cadaver;
    
    public HebraEntrada(CadaverExquisito cadaver, Socket socket){
        //Creamos los flujos necesarios
        this.cadaver = cadaver;
        try {
            out2 = new PrintWriter(socket.getOutputStream(), true);
            in2 = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (IOException ex) {
            System.out.println("Error en la creación del flujo de datos");
            Logger.getLogger(HebraEntrada.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    public void run(){
      do{
        try {
            //Durante todo el tiempo de ejecución estamos leyendo en el socket de entrada
            //por si el servidor envía algún mensaje
            String mensaje = in2.readLine();
            StringTokenizer cachos;
            Dibujo trazo;
            //Recorremos la lista de trazos recibidos hasta llegar al final
            while (!mensaje.equals("Fin")) {
                //Almacenamos lo recibido en un StringTokenizer para partirlo en trozos
                cachos = new StringTokenizer(mensaje, ",");
                //Tomamos el trazo y lo dibujamos
                trazo = new Dibujo(0, Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()), Integer.parseInt(cachos.nextToken()));
                cadaver.getCanvas().setForeground(new Color(trazo.r, trazo.g, trazo.b));
                cadaver.getCanvas().getGraphics().drawLine(trazo.x1, trazo.y1, trazo.x2, trazo.y2);
                if (trazo.grosor > 0) {
                    cadaver.getCanvas().getGraphics().drawLine(trazo.x1 + 1, trazo.y1, trazo.x2 + 1, trazo.y2);
                    cadaver.getCanvas().getGraphics().drawLine(trazo.x1, trazo.y1 + 1, trazo.x2, trazo.y2 + 1);
                    cadaver.getCanvas().getGraphics().drawLine(trazo.x1 + 2, trazo.y1, trazo.x2 + 2, trazo.y2);
                    cadaver.getCanvas().getGraphics().drawLine(trazo.x1, trazo.y1 + 2, trazo.x2, trazo.y2 + 2);
                    if (trazo.grosor == 2) {
                        cadaver.getCanvas().getGraphics().drawLine(trazo.x1 + 3, trazo.y1, trazo.x2 + 3, trazo.y2);
                        cadaver.getCanvas().getGraphics().drawLine(trazo.x1, trazo.y1 + 3, trazo.x2, trazo.y2 + 3);
                        cadaver.getCanvas().getGraphics().drawLine(trazo.x1 + 4, trazo.y1, trazo.x2 + 4, trazo.y2);
                        cadaver.getCanvas().getGraphics().drawLine(trazo.x1, trazo.y1 + 4, trazo.x2, trazo.y2 + 4);
                    }
                }
                //Confirmamos el fin de la operación al servidor
                out2.println("ok");
                //Vemos si hay otro mensaje
                mensaje = in2.readLine();
            }
        } catch (IOException ex) {
            Logger.getLogger(HebraEntrada.class.getName()).log(Level.SEVERE, null, ex);
        }
      }while(!salir);
    }
}

/**
 * Clase que representa un trazo del dibujo
 * @author Julio Navarro Lara
 */
class Dibujo{
    int origen; //De dónde viene el trazo
    int x1,x2,y1,y2; //Coordenada iniciales y finales
    int r,g,b; //Componentes de color
    int grosor; //Grosor del trazo

    public Dibujo(int origen, int x1, int x2, int y1, int y2, int r, int g, int b, int grosor){
        this.origen = origen;
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
        this.r = r;
        this.g = g;
        this.b = b;
        this.grosor = grosor;
    }
}

