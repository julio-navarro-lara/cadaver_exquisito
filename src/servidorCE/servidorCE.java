/*
 * servidorCE.java
 *
 * Created on 03-abr-2010, 17:53:53
 *
 * By Julio Navarro Lara
 * *********************
 * Telemática Aplicada - 3º Ing. de Telecomunicaciones
 */

package servidorCE;

import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.ServerSocket;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.StringTokenizer;

/**
 * Clase que implementa el servidor del "cadáver exquisito"
 * @author Julio Navarro Lara
 */
public class servidorCE extends javax.swing.JFrame {

    //Contador para asignar números a los usuarios
    int contador;

    //Cadena de texto con la información del proceso
    String str;

    //Lista de trazos recibidos por los usuarios
    ArrayList<Dibujo> listaTrazos = new ArrayList<Dibujo>();

    //Constructor
    public servidorCE() {
        //Iniciamos la ventana
        initComponents();
        //Inicializamos el contador a 1
        contador = 1;

        //Vamos a ir mostrando por pantalla la información relativa a todas las conexiones
        str = "Conectando...";
        info.setText(str);

        appendText("\nEstableciendo socket servidor en el puerto 24..." +
                "\nClick en el botón de escuchar para comenzar la comunicación.");
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        textoPuerto = new javax.swing.JTextField();
        puertoLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        info = new javax.swing.JTextArea();
        botonEscuchar = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        textoPuerto.setText("24");

        puertoLabel.setText("Puerto: ");

        info.setColumns(20);
        info.setRows(5);
        jScrollPane1.setViewportView(info);

        jScrollPane2.setViewportView(jScrollPane1);

        botonEscuchar.setText("Escuchar");
        botonEscuchar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonEscucharActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(puertoLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(textoPuerto, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 94, Short.MAX_VALUE)
                        .addComponent(botonEscuchar)
                        .addGap(118, 118, 118)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(puertoLabel)
                    .addComponent(textoPuerto, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(botonEscuchar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 249, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Controlador de la pulsación sobre el botón Escuchar
     * @param evt
     */
    private void botonEscucharActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonEscucharActionPerformed

        appendText("\nLeyendo información de puerto...");

        //Tomamos el puerto que haya escrito en el cuadro
        int puerto = Integer.parseInt(textoPuerto.getText());

        appendText("\nCreando nuevo servidor...");

        //Creamos una nueva hebra para gestionar el servicio
        new GestionServicio(puerto, this).start();

        //Deshabilitamos el botón para evitar posibles sockets de servicio en un mismo puerto
        botonEscuchar.setEnabled(false);
    }//GEN-LAST:event_botonEscucharActionPerformed

    /**
     * Devuelve la lista de trazos
     * @return
     */
    ArrayList<Dibujo> getTrazos(){
        return listaTrazos;
    }

    /**
     * Añade el texto correspondiente al cuadro de información
     * @param texto
     */
    public void appendText(String texto){
        str += texto;
        info.setText(str);
    }

    /**
     * Devuelve el contador que asigna los números a los usuarios
     * @return
     */
    public int getContador(){
        return contador;
    }

    /**
     * Incrementa en 1 el valor del contador
     */
    public void incContador(){
        contador++;
    }

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new servidorCE().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton botonEscuchar;
    private javax.swing.JTextArea info;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel puertoLabel;
    private javax.swing.JTextField textoPuerto;
    // End of variables declaration//GEN-END:variables

}

/**
 * Clase que implementa una hebra para gestionar las tareas del servidor
 * @author Julio Navarro Lara
 */
class GestionServicio extends Thread{

    //Puerto de conexión
    int puerto;

    ServerSocket socketServicio;
    servidorCE server;

    boolean salir; //Variable para interrumpir la admisión de hebras nuevas

    /**
     * Constructor de la hebra
     * @param puerto
     * @param server
     */
    public GestionServicio(int puerto, servidorCE server){
        this.server = server;
        this.puerto = puerto;
        salir = false;
    }

    public void run(){
        try {
            //Creamos un nuevo Socket servidor en el puerto especificado
            socketServicio = new ServerSocket(puerto);
        } catch (IOException ex) {
            Logger.getLogger(servidorCE.class.getName()).log(Level.SEVERE, null, ex);
        }

        //Vamos aceptando conexiones de los usuarios
        do{
            try {
                server.appendText("\nIniciando hebra de entrada "+server.getContador()+"...");

                //Aceptamos una nueva conexión
                Socket conectionSocket = socketServicio.accept();

                //Creamos una nueva hebra de atención de las entradas (los trazos que
                //envían los usuarios)
                new AtencionEntrada(conectionSocket, server.getContador(), server).start();

                server.appendText("\nIniciando hebra de salida "+server.getContador()+"...");

                //Esperamos ahora a aceptar una nueva conexión del mismo usuario para que reciba
                //las hebras de los demás
                Socket conectionSocket2 = socketServicio.accept();

                //Creamos una nueva hebra que atienda esto
                new AtencionSalida(conectionSocket2, server.getContador(), server).start();

                //Incrementamos el contador de usuarios
                server.incContador();

            } catch (IOException ex) {
                server.appendText("\nFallo en la conexión");
                Logger.getLogger(servidorCE.class.getName()).log(Level.SEVERE, null, ex);
            }
        }while(!salir);
    }
}

/**
 * Hebra de atención a los mensajes que entran al servidor
 * @author Julio Navarro Lara
 */
class AtencionEntrada extends Thread{

    //Variables necesarias para la atención de los mensajes
    Socket socket;
    servidorCE servidor;

    Dibujo dibujo;
    String mensaje;

    boolean salir;
    int numero;
    int contador;

    PrintWriter out;
    BufferedReader in;

    public AtencionEntrada(Socket socket, int numeroUsuario, servidorCE server){
        //Inicializamos variables y flujos
        this.socket = socket;
        servidor = server;
        numero = numeroUsuario;
        try {
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            servidor.appendText("\nUsuario "+numero+": Flujo de datos creado con éxito.");
        } catch (IOException ex) {
            servidor.appendText("\nUsuario "+numero+": Error en la creación del flujo de datos.");
        }
    }

    public void run(){
        //Le enviamos al usuario el número que tiene asignado
        out.println(numero);

        do{
            try {
                //El servidor está todo el rato leyendo mensajes del usuario
                mensaje = in.readLine();

                //Si le llega información de un trazo, la divide en trozos y crea un
                //nuevo objeto de la clase Dibujo
                StringTokenizer mensajeACachos = new StringTokenizer(mensaje, ",");

                dibujo = new Dibujo(Integer.parseInt(mensajeACachos.nextToken()),Integer.parseInt(mensajeACachos.nextToken()),
                        Integer.parseInt(mensajeACachos.nextToken()),Integer.parseInt(mensajeACachos.nextToken()),Integer.parseInt(mensajeACachos.nextToken()),
                        Integer.parseInt(mensajeACachos.nextToken()),Integer.parseInt(mensajeACachos.nextToken()),Integer.parseInt(mensajeACachos.nextToken()),
                        Integer.parseInt(mensajeACachos.nextToken()));

                //Envía al usuario la confirmación
                out.println("ok");

                //Se indica el proceso en el cuadro informativo
                servidor.appendText("\nUsuario "+numero+": Trazo almacenado con éxito.");

                //Se añade el trazo a la lista correspondiente
                servidor.getTrazos().add(dibujo);

            } catch (IOException ex) {
                servidor.appendText("\nUsuario "+numero+": Error en la recepción de los datos");
            }
        }while(!salir);

        try{
            //Cuando terminamos con este usuario, cerramos los flujos y el socket
            servidor.appendText("\nUsuario "+numero+": Cerrando flujos.");
            out.close();
            in.close();
            socket.close();
        }catch(IOException e){
            servidor.appendText("\nUsuario "+numero+": Error al cerrar los flujos");
        }
    }

}

/**
 * Hebra para gestionar los mensajes que se envían al usuario
 * @author Julio Navarro Lara
 */
class AtencionSalida extends Thread{
    Socket socket;
    servidorCE servidor;

    boolean salir;
    int numero;
    //El contador indica desde qué punto hay trazos sin enviar al usuario
    int contador;

    Dibujo dibujo;
    String mensaje;

    PrintWriter out;
    BufferedReader in;

    public AtencionSalida(Socket socket, int numeroUsuario, servidorCE server){
        //Inicializamos todo (variables y flujos)
        this.socket = socket;
        servidor = server;
        numero = numeroUsuario;
        contador = 0;
        try {
            out = new PrintWriter(socket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            servidor.appendText("\nUsuario "+numero+": Flujo de datos de salida creado con éxito.");
        } catch (IOException ex) {
            servidor.appendText("\nUsuario "+numero+": Error en la creación del flujo de salida.");
        }
    }

    public void run(){

        do{
            try {
                //Recorremos todos aquellos trazos que todavía no se han enviado al usuario
                //Cuando acaba el bucle, lo volvemos a repetir a la espera de trazos nuevos
                for(int i=contador; i<servidor.getTrazos().size(); i++){
                    dibujo = servidor.getTrazos().get(i);
                    contador++; //Incrementamos el contador: el trazo correspondiente ya está enviado
                    //Si el trazo es de otro usuario, se envía a este usuario codificado de forma que pueda
                    //luego interpretar la información
                    if(dibujo.origen != numero)
                    {
                        servidor.appendText("\nUsuario "+numero+": Enviando trazo de "+dibujo.origen);
                        out.println(dibujo.x1+","+dibujo.x2+","+dibujo.y1+","+dibujo.y2+
                                ","+dibujo.r+","+dibujo.g+","+dibujo.b+","+dibujo.grosor);
                        //Se espera confirmación por parte del usuario
                        mensaje = in.readLine();
                        if(!mensaje.equals("ok")){
                            servidor.appendText("\nUsuario "+numero+": Fallo en el envío de trazo de "+dibujo.origen);
                            break;
                        }
                    }
                }

                //Indicamos cuando se termina de enviar esta tanda de trozos
                //(o si no se envía ninguno)
                out.println("Fin");

            } catch (IOException ex) {
                servidor.appendText("\nUsuario "+numero+": Fallo en el intercambio de datos.");
            }
        }while(!salir);

        try{
            //Cerramos socket y flujos
            servidor.appendText("\nUsuario "+numero+": Cerrando los flujos de datos.");
            out.close();
            in.close();
            socket.close();
        }catch(IOException e){
            servidor.appendText("\nUsuario "+numero+": Error al cerrar los flujos.");
        }
    }


}

/**
 * Clase que almacena los datos de un trazo. Es análoga a la definida en cada usuario.
 * @author Julio Navarro Lara
 */
class Dibujo{
    int origen; //Usuario del que procede el trazo
    int x1,x2,y1,y2; //Coordenadas de origen y destino del trazo
    int r,g,b; //Componentes de color del trazo
    int grosor; //Grosor del trazo

    public Dibujo(int origen, int x1, int x2, int y1, int y2, int r, int g, int b, int grosor){
        this.origen = origen;
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
        this.r = r;
        this.g = g;
        this.b = b;
        this.grosor = grosor;
    }
}
